# 1주차 질문 리스트

<br>

## 정호

#### MySQL은 멀티쓰레드 방식으로 작업이 수행된다. 포그라운드 쓰레드와 백그라운드 쓰레드에 대해서 아는만큼 말을 해주세요.

* **포그라운드 스레드는** 최소한 MySQL 클라이언트 수만큼 존재합니다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면, 해당 커넥션을 담당하는 스레드는 스레드 캐시로 돌아갑니다. 만약 스레드 캐시에 일정 갯수 이상의 대기중인 스레드가 있으면 해당 스레드를 캐시에 넣지 않고 종료하여 갯수를 일정하게 유지해줍니다. 포그라운드 스레드는 스토리지 엔진의 종류에 따라 역할의 범위가 달라집니다. MyISAM 엔진은 버퍼나 캐시로 부터 데이터를 가져오는 것을 넘어서서 디스크에 접근하여 데이터를 가져오거나 쓰기 작업까지 포그라운드 스레드가 수행합니다. 반면에 InnoDB 엔진에서의 포그라운드 스레드는 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리합니다. 나머지 디스크 관련 쓰기 작업은 백그라운드 스레드가 수행하는 특징이 있습니다. <br/><br/>
**백그라운드 스레드는** InnoDB 엔진 기준으로 인서트 버퍼를 병합하며, 로그를 디스크로 기록하고, 버퍼 풀의 데이터를 디스크에 기록하는 역할들을 수행합니다. 가장 중요한 것은 디스크로 내려쓰는 작업을 하는 쓰기 쓰레드입니다. InnoDB에서 쓰기 지연이 가능한 이유도 다른 엔진에서는 쓰기 작업도 포그라운드 스레드에서 처리하게 되어 버퍼링 기능을 활용할 수 없지만, InnoDB에서 쓰기 작업은 백그라운드 스레드가 담당하여 쓰기 지연 작업을 할 수 있는 특징이 있습니다.

<br/><br/>

#### 메모리 할당 구조에 대해서 설명하실 수 있나요?
* MySQL의 메모리는 크게 두가지로 나눌 수 있습니다. **글로벌 메모리 영역과 세션 메모리 영역입니다.** <br/><br/> 글로벌 메모리 영역은 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당이 됩니다. 필요에 따라 하나 이상의 공간을 할당 받을 수도 있지만 실제 클라이언트 스레드 수와는 무관합니다. 또한 모든 스레드에 의해 공유되는 특징이 있습니다. 대표적인 글로벌 메모리는 (테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼) 등이 있습니다. <br/><br/> 로컬 메모리 영역은 세션 메모리 영역이라고도 부릅니다. MySQL에서 세션은 클라이언트 커넥션으로 부터 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데, 이 스레드가 활용하는 메모리가 바로 로컬 메모리입니다. MySQL과 클라잉너트간의 커넥션을 세션이라고 부르기 때문에, 로컬 메모리를 세션 메모리라고도 부릅니다. 로컬 메모리는 스레드 별로 독립적으로 할당되어 절대 공유되지 않는 특징이 있습니다. 종류로는 (소트 버퍼, 조인 버퍼, 커넥션 버퍼, 결과 버퍼) 등이 있습니다. 소트 버퍼나 조인 버퍼는 사용하지 않을 경우 메모리 공간을 할당조차 하지 않을 수도 있지만, 커넥션버퍼나 결과 버퍼는 커넥션이 열려 있는 동안 계속 메모리가 할당된 상태로 남아있는 특징이 있습니다.

<br/><br/>

#### 쿼리 요청이 왔을 때, 어떤 과정을 통해서 작업이 이루어지는지?
* 쿼리파서가 쿼리 문장을 MySQL이 인시갈 수 있는 최소 단위의 트리형태로 만들어 냅니다. 쿼리 문장에서의 기본 문법 오류는 이 과정에서 발견됩니다. 다음으로 전처리기가 파서 트리를 기반으로 쿼리 문장의 구조적인 문제점이 있는지 확인합니다. 테이블 이름이나 칼럼이름 또는 내장 함수와 같은 개체를 매핑하여 객체의 존재 여부와 접근권한을 확인하는 과정이 이 단계에서 수행됩니다. 다응으로는 옵티마이저가 쿼리 문장을 가장 빠르게 어떻게 처리할지를 계획을 세웁니다. 그리고 실행엔진이 옵티마이저가 세운 계획을 기반으로 핸들러에게 요청하여 결과를 받는 식으로 전체적인 쿼리가 실행되게 됩니다.

<br/><br/>

#### innoDB의 프라이머리 키에 의한 클러스터링에 대해서 설명해주세요.
* InnoDb의 모든 테이블을 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장됩니다. 이를 다른 말로 하자면, 프라이머리 키값의 순서대로 디스크에 저장된다는 말이됩니다. 또한 프라이머리 키 엔덱스를 제외한 모든 세컨더리 인덱스는 레코드의 주소 대신에 프라이머리 키의 값을 논리적인 주소로 활용하게 됩니다. MyISAM과 다르게 InnoDB는 프라이머리 키에 의한 클러스트링 인덱스를 사용하기 때문에 일정 범위를 탐색하는 레인지 스캔이 상당히 빠르게 처리되는 특징이 있습니다. 또한 쿼리 실행 계획에서 다른 보조 인덱스보다 프라이머리키 인덱스가 우선순위가 높게 설정됩니다. 

<br/><br/>

#### innoDB의 외래키 지원에 대해서 설명해주세요.
* 이전의 스토리지 엔진과 다르게 InnoDB는 외래키에 대한 지원을 해줍니다. 이것으 다른 말로 하면 데이터의 무결성을 지키도록 도와주는 말이 됩니다. InnoDB에서는 외래키에 대한 인덱스를 자동으로 생성하고, 외래키 검사를 해줍니다. 외래키로 지정한 부모 테이블의 데이터가 존재하지 않으면 해당 작업을 거부하는 것이 그에 대한 예시입니다. 뿐만 아니라 'ON DELETE', 'ON UPDATE' 옵션과 같이 부모 테이블의 데이터가 수정되거나 삭제될 때 자식 테이블의 데이터의 행동 방식을 지정할 수 있는 기능도 제공해줍니다.

<br/><br/>

#### 리두 로그보다 버퍼풀이 훨씬 클 때, 버퍼풀이 리두 로그가 훨씬 클 때 뭐가 다를까?
* 리두 로그 보다 버퍼풀의 크기가 훨씬 클 때, 쓰기 버퍼링에 의한 성능 효과를 거의 보지 못하는 상황이 발생합니다. 버퍼풀에는 데이터 변경이 없는 클린페이지 말고도 변경된 데이터인 더티페이지도 가지고 있습니다. 그리고 더티페이지는 리두 로그와 순환고리 처럼 연결되어 있습니다. 일정 체크포인트가 되면 리두 로그를 활용하여 버퍼풀에 있는 더티페이지를 디스크에 동기화하게 되는데, 만약 리두 로그 파일의 크기가 너무 작게 되면, 버퍼풀에 허용가능한 더티페이지의 용량이 줄어들어 쓰기 버퍼링에 대한 효과를 보지 못하게 되는 것입니다. <br/> 반대로 버퍼풀의 용량이 작고, 리두 로그 파일의 전체 크기가 훨씬 클때는 갑작스러운 디스크 쓰기 현상이 발생할 수 있습니다. 체크포인트 시점 이전에 버퍼풀에 더티페이지의 비율이 너무 높게 되면, 이를 한 순간에 디스크로 기록해야되는데, 이 때 매우 많은 페이지를 한번에 기록해야되므로 서버에 부담을 줄 수 있습니다. 따라서 리두로그 파일의 크기와 버퍼 풀의 크기를 적절하게 조절하여 사용하는것이 중요합니다. 일반적으로 버퍼풀 보다 리두 로그는 더 작은 공간만 있으면 됩니다.  버퍼풀에 있는 모든 페이지가 더티페이지는 아니기 때문입니다.

<br/><br/>

#### 플러시 리스트 플러시에 대해서 설명해주세요.
* InnoDB 스토리지 엔진에서는 리두 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용된 공간을 비워줘야 합니다. 이 떄 오래된 리두 로그 공간이 지워지려면 그전에 반드시 InnoDB 버퍼풀에 있는 더티페이지가 먼저 디스크로 동기화되어야 합니다. 이 작업을 위해 스토리지 엔진은 주기적으로 플러시 리스트 플러시 함수를 호출하여 플러시 리스트에 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화 하는 작업을 수행합니다. 


<br>

## 의찬

#### 버퍼풀의 경우 바로 디스크에 반영하는 것이 아니라, 모아놨다가 이따금 한 번씩 하게된다. 따라서 장애시 데이터가 유실 가능하다. 따라서 리두 로그에 기록된다.
* 

#### innoDB 쿼리 캐시가 없어졌다. 왜 그럴까?
* 

<br>

## 지훈

#### 어댑티브 해시 인덱스에 대해서 설명해주세요. 카카오 블로그에 어댑티브 해시 인덱스를 활용한 사례가 있다. 어떤 경우에 어댑티브 해시 인덱스를 쓰는 것이 좋겠는가?
* 

#### LRU 리스트 플러시는 무엇인가요?
* 

<br>

## 성민

#### MVCC 방식 Lock을 이용한 방식에 비해서 어떤 장점이 있는가?
* 

<br>

## 민욱

#### 자동 데드락 기능에서, 데드락을 어떻게 판단하는지?
* 

#### 버퍼풀의 구조에 대해서 설명해주세요.
* 
